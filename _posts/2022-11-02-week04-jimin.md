---
layout: post
title: 4주차 활동 일지_지민
subtitle:
categories: Jimin
tags: #Jimin
---
## 네 번째 활동 일지
**일시 :** 2022.11.02 16:00~18:00  
**작성자 :** 콘텐츠IT전공 20215263 최지민 <br>

**주요 학습 내용**

- 상수형 함수
- 인라인 함수
- C++ 구조체
- 헤더 파일의 중복 include 문제
- 헤더 파일과 cpp 파일 분리
<br>

**오늘의 학습 계획** 

1. 해당 부분의 ppt 복습과 공부 ( 클래스와 객체 ppt )
2. 5주차 실습 문제 코딩

### 요약 정리 
상수형 함수
- 멤버 변수에 읽기 접근은 가능하지만 쓰기는 허용되지 않는 메소드
- 상수형 함수는 상수형 함수만 호출 가능

```c++
int getRadius() const; //상수형 함수 선언

int Circle::getRadius() const {
cout<<getArea(); //error, 상수형 함수만 호출 가능
radius = 50; //error, 멤버 변수 변경 금지
//(1)처럼 멤버 변수를 선언하면 변경 가능
return radius;
}
```

- 쓰기 작업을 허용하고 싶다면, mutable 사용
- 상수형 참조 -> 일반 참조로 형 변환 :　int &newParam = const_cast<int &>(param)

인라인 함수
- inline 키워드로 선언된 함수
- 인라인 함수를 호출하는 곳에 인라인 함수 코드를 확장 삽입
- C++ 프로그램의 실행 속도 향상 : 자주 호출되는 짧은 코드의 함수 호출에 대한 시간 소모를 줄임
- 자동 인라인 함수 : 클래스 선언부에 구현된 멤버 함수
	- inline으로 선언할 필요 없음
	- 컴파일러에 의해 자동으로 인라인 처리
	- 생성자를 포함, 모든 함수가 자동 인라인 함수 가능
```c++
class Circle {
	private:
		int radius;
	public:
		Circle() { // 자동 인라인 함수
			radius = 1;
		}
	Circle(int r); 
	double getArea() { // 자동 인라인 함수
		return 3.14*radius*radius;
	}
};
```

C++ 구조체
- 상속, 멤버, 접근 지정 등 모든 것이 클래스와 동일
- 클래스와의 차이점 : 구조체의 디폴트 접근 지정은 public
- C++에서 구조체 객체를 생성하는 경우, struct 키워드는 생략해도 됨 EX) structName stObj

헤더 파일과 cpp 파일 분리
- 클래스마다 분리 저장
- 인터페이스 파일 – 클래스 선언 부, 헤더 파일에 저장
- 구현파일 – 클래스 구현 부, cpp 파일에 저장
	- 클래스가 선언된 헤더 파일 include
- 어플리케이션 파일
	- main 함수의 코드가 포함된 파일
	- 필요하면 클래스가 선언된 헤더 파일 include
- 헤더 파일 중복 include 문제
  - 중복 include 문제로, #ifndef #define으로 조건 컴파일을 사용
<br>


### 학습 평가
자동 인라인 부분의 이해가 부족해 참고 자료를 찾아본 결과, <br>
inline 키워드를 명시하지 않아도 클래스의 정의부에 같이 함수의 기능을 끼워 넣으면 컴파일러가 자동으로 인라인 처리를 하는 것을 말한다.<br>
인라인 함수는 성능을 개선해 주지만, 너무 많이 사용할 경우 전체적인 코드의 양이 늘어나 역효과를 낼 수 있다는 점을 알아야 한다.<br>
C++을 제대로 작성하는 방법의 경우 한 파일에 모두 작성하는 것이 아닌 헤더 파일과 cpp 파일을 분리하여 작성해야 하는데,<br>
이 부분의 경우 이해가 확실하지 않아 코드를 직접 짜보면서 이해해야 할 필요가 있을 것 같다.<br>
또한, 중복 include의 문제로 include의 경우 조건 컴파일을 사용해 주는 것이 좋다는 것을 기억해야 한다.
